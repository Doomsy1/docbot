"""Renderer -- turn a DocsIndex into markdown files and an HTML index.

When an LLM client is provided, ALL narrative documentation is LLM-written:
per-scope module docs, README, and architecture. Templates are fallbacks only.
"""

from __future__ import annotations

import asyncio
import html as html_mod
import logging
from pathlib import Path

from .models import DocsIndex, ScopeResult

logger = logging.getLogger(__name__)


def _h(text: str) -> str:
    """HTML-escape helper."""
    return html_mod.escape(text, quote=True)


# ---------------------------------------------------------------------------
# LLM prompts
# ---------------------------------------------------------------------------

_SCOPE_DOC_SYSTEM = """\
You are a technical writer producing module documentation for a Python \
repository. Write clear, thorough markdown based on the structured data. \
Never invent features not evidenced in the data. Include file and line \
references where relevant."""

_SCOPE_DOC_PROMPT = """\
Write comprehensive documentation for this module/scope of a Python repository.

Scope: {title} (ID: {scope_id})
Files ({file_count}): {file_list}
Key files: {key_files}
Entrypoints: {entrypoints}

Public API ({api_count} symbols):
{api_block}

Environment variables: {env_block}

Raised errors ({error_count}):
{error_block}

Summary from exploration:
{summary}

Write a thorough module documentation page in markdown including:
1. An overview section explaining the module's purpose and responsibilities.
2. A "Public API" section documenting each function/class with its signature, \
   what it does, and where it's defined (file:line).
3. An "Environment Variables" table if any exist.
4. An "Error Handling" section if there are raised errors.
5. A "Files" section listing all files with a one-line description of each.

Use markdown headers. Reference specific files and line numbers."""

_README_SYSTEM = """\
You are a technical writer producing a README for a Python repository. \
Write clear, accurate markdown based only on the structured data provided. \
Never invent features or behaviors not evidenced in the data."""

_README_PROMPT = """\
Generate a README.md for this Python repository.

Repository path: {repo_path}

Scopes ({scope_count}):
{scope_summaries}

Cross-scope analysis:
{cross_scope_analysis}

Entrypoints: {entrypoints}
Environment variables: {env_vars}
Public API symbol count: {api_count}

The README should include:
1. A title and one-paragraph project description.
2. A "Project structure" section listing the scopes and what each covers.
3. An "Entrypoints" section if any exist.
4. An "Environment variables" table if any exist.
5. Links to docs/architecture.generated.md, docs/api.generated.md, \
   and per-module docs under docs/modules/.

End with a note that this was auto-generated by docbot. Stay factual."""

_ARCH_SYSTEM = """\
You are a software architect writing an architecture overview for a Python \
repository. Base your analysis only on the structured data provided."""

_ARCH_PROMPT = """\
Write an architecture overview document (markdown) for this Python repository.

Repository: {repo_path}

Cross-scope analysis:
{cross_scope_analysis}

Scopes and their summaries:
{scope_details}

Entrypoints: {entrypoints}
Environment variables: {env_vars}
Total public API symbols: {api_count}
Total raised error types: {error_count}
Failed scopes: {failed_scopes}

The document should cover:
1. High-level structure: how the codebase is organized.
2. Component relationships: which scopes depend on each other and why.
3. Entry points and how the application is started.
4. Configuration and environment: what external config the app needs.
5. Error handling patterns if notable.

Use markdown headers. Reference specific files and symbols."""


# ---------------------------------------------------------------------------
# Template-based fallbacks (used when LLM is unavailable)
# ---------------------------------------------------------------------------

def _render_scope_md_template(scope: ScopeResult) -> str:
    """Template-based scope doc."""
    lines: list[str] = []
    lines.append(f"# {scope.title}\n")
    lines.append(f"**Scope ID:** `{scope.scope_id}`\n")

    if scope.error:
        lines.append(f"> **Exploration failed:** {scope.error}\n")
        return "\n".join(lines)

    lines.append(f"{scope.summary}\n")

    lines.append("## Files\n")
    for p in scope.paths:
        lines.append(f"- `{p}`")
    lines.append("")

    if scope.key_files:
        lines.append("## Key files\n")
        for p in scope.key_files:
            lines.append(f"- `{p}`")
        lines.append("")

    if scope.entrypoints:
        lines.append("## Entrypoints\n")
        for p in scope.entrypoints:
            lines.append(f"- `{p}`")
        lines.append("")

    if scope.public_api:
        lines.append("## Public API\n")
        for sym in scope.public_api:
            doc = f" -- {sym.docstring_first_line}" if sym.docstring_first_line else ""
            lines.append(f"### `{sym.signature}`{doc}\n")
            lines.append(f"- Kind: {sym.kind}")
            c = sym.citation
            lines.append(f"- Defined in `{c.file}` lines {c.line_start}-{c.line_end}")
            lines.append("")

    if scope.env_vars:
        lines.append("## Environment variables\n")
        lines.append("| Variable | Default | Location |")
        lines.append("|----------|---------|----------|")
        for ev in scope.env_vars:
            default = f"`{ev.default}`" if ev.default else "-"
            loc = f"`{ev.citation.file}:{ev.citation.line_start}`"
            lines.append(f"| `{ev.name}` | {default} | {loc} |")
        lines.append("")

    if scope.raised_errors:
        lines.append("## Raised errors\n")
        for err in scope.raised_errors:
            c = err.citation
            lines.append(f"- `{err.expression}` at `{c.file}:{c.line_start}`")
        lines.append("")

    if scope.open_questions:
        lines.append("## Open questions\n")
        for q in scope.open_questions:
            lines.append(f"- {q}")
        lines.append("")

    return "\n".join(lines)


def _render_readme_template(index: DocsIndex) -> str:
    lines: list[str] = []
    lines.append("# Repository documentation\n")
    lines.append(f"Auto-generated by **docbot** at `{index.generated_at}`.\n")
    lines.append(f"Repository: `{index.repo_path}`\n")
    lines.append("## Scopes\n")
    for s in index.scopes:
        status = "(failed)" if s.error else ""
        lines.append(f"- [{s.title}](docs/modules/{s.scope_id}.generated.md) {status}")
    lines.append("")
    lines.append("## Quick links\n")
    lines.append("- [Architecture overview](docs/architecture.generated.md)")
    lines.append("- [API reference](docs/api.generated.md)")
    lines.append("- [HTML report](index.html)")
    lines.append("")
    if index.entrypoints:
        lines.append("## Entrypoints\n")
        for ep in index.entrypoints:
            lines.append(f"- `{ep}`")
        lines.append("")
    if index.env_vars:
        lines.append("## Environment variables\n")
        lines.append("| Variable | Default | Location |")
        lines.append("|----------|---------|----------|")
        for ev in index.env_vars:
            default = f"`{ev.default}`" if ev.default else "-"
            loc = f"`{ev.citation.file}:{ev.citation.line_start}`"
            lines.append(f"| `{ev.name}` | {default} | {loc} |")
        lines.append("")
    return "\n".join(lines)


def _render_architecture_template(index: DocsIndex) -> str:
    lines: list[str] = []
    lines.append("# Architecture overview\n")
    lines.append(f"Repository: `{index.repo_path}`\n")
    if index.cross_scope_analysis:
        lines.append(index.cross_scope_analysis)
        lines.append("")
    lines.append("## Scope map\n")
    total_files = 0
    for s in index.scopes:
        n = len(s.paths)
        total_files += n
        lines.append(f"- **{s.title}** (`{s.scope_id}`) -- {n} file(s)")
    lines.append(f"\nTotal Python files covered: {total_files}\n")
    if index.entrypoints:
        lines.append("## Entrypoints\n")
        for ep in index.entrypoints:
            lines.append(f"- `{ep}`")
        lines.append("")
    failed = [s for s in index.scopes if s.error]
    if failed:
        lines.append("## Exploration failures\n")
        for s in failed:
            lines.append(f"- **{s.title}**: {s.error}")
        lines.append("")
    return "\n".join(lines)


def _render_api(index: DocsIndex) -> str:
    lines: list[str] = []
    lines.append("# API reference\n")
    if not index.public_api:
        lines.append("No public symbols were extracted.\n")
        return "\n".join(lines)
    by_file: dict[str, list] = {}
    for sym in index.public_api:
        by_file.setdefault(sym.citation.file, []).append(sym)
    for fpath in sorted(by_file):
        lines.append(f"## `{fpath}`\n")
        for sym in by_file[fpath]:
            doc = f" -- {sym.docstring_first_line}" if sym.docstring_first_line else ""
            lines.append(f"### `{sym.signature}`{doc}\n")
            c = sym.citation
            lines.append(f"- Kind: {sym.kind}")
            lines.append(f"- Lines {c.line_start}-{c.line_end}")
            lines.append("")
    return "\n".join(lines)


def _render_mermaid_fallback(index: DocsIndex) -> str:
    """Simple deterministic Mermaid when LLM didn't generate one."""
    lines = ["graph TD"]
    scope_ids = {s.scope_id for s in index.scopes}
    ep_scopes = {s.scope_id for s in index.scopes if s.entrypoints}
    for s in index.scopes:
        label = s.title
        sid = s.scope_id
        if s.error:
            lines.append(f'    {sid}["{label}"]:::failed')
        elif sid in ep_scopes:
            lines.append(f'    {sid}(["{label}"]):::entrypoint')
        elif sid == "crosscutting":
            lines.append(f'    {sid}{{{{"{label}"}}}}:::crosscutting')
        else:
            lines.append(f'    {sid}["{label}"]')
    for src, dst in index.scope_edges:
        if src in scope_ids and dst in scope_ids:
            lines.append(f"    {src} --> {dst}")
    lines.append("    classDef entrypoint fill:#2563eb,stroke:#1d4ed8,color:#fff")
    lines.append("    classDef crosscutting fill:#f59e0b,stroke:#d97706,color:#fff")
    lines.append("    classDef failed fill:#ef4444,stroke:#dc2626,color:#fff")
    return "\n".join(lines)


def _get_mermaid(index: DocsIndex) -> str:
    """Return the Mermaid definition -- LLM-generated if available, else fallback."""
    return index.mermaid_graph if index.mermaid_graph else _render_mermaid_fallback(index)


def _render_index_html(index: DocsIndex) -> str:
    """Generate a self-contained HTML report with rendered Mermaid graph."""
    scope_rows = ""
    for s in index.scopes:
        status = f'<span style="color:#e74c3c">FAILED</span>' if s.error else f'<span style="color:#2ecc71">OK</span>'
        n_api = len(s.public_api)
        n_env = len(s.env_vars)
        n_err = len(s.raised_errors)
        link = f"docs/modules/{s.scope_id}.generated.md"
        scope_rows += f"""<tr>
  <td><a href="{_h(link)}">{_h(s.title)}</a></td>
  <td>{len(s.paths)}</td>
  <td>{n_api}</td>
  <td>{n_env}</td>
  <td>{n_err}</td>
  <td>{status}</td>
</tr>\n"""

    env_rows = ""
    for ev in index.env_vars:
        default = _h(ev.default) if ev.default else "-"
        env_rows += f"""<tr>
  <td><code>{_h(ev.name)}</code></td>
  <td>{default}</td>
  <td><code>{_h(ev.citation.file)}:{ev.citation.line_start}</code></td>
</tr>\n"""

    mermaid_def = _get_mermaid(index)

    return f"""<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>docbot report - {_h(index.repo_path)}</title>
<style>
  body {{ font-family: system-ui, -apple-system, sans-serif; margin: 2rem; background: #fafafa; color: #222; }}
  h1 {{ border-bottom: 2px solid #333; padding-bottom: .3rem; }}
  a {{ color: #2563eb; }}
  table {{ border-collapse: collapse; width: 100%; margin: 1rem 0; }}
  th, td {{ border: 1px solid #ccc; padding: .4rem .6rem; text-align: left; }}
  th {{ background: #eee; }}
  .meta {{ color: #666; font-size: .9rem; }}
  nav a {{ margin-right: 1rem; }}
  .mermaid {{ background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 1.5rem; margin: 1rem 0; }}
</style>
</head>
<body>
<h1>docbot report</h1>
<p class="meta">Repository: <code>{_h(index.repo_path)}</code><br>
Generated: <code>{_h(index.generated_at)}</code></p>

<nav>
  <a href="README.generated.md">README</a>
  <a href="docs/architecture.generated.md">Architecture</a>
  <a href="docs/api.generated.md">API reference</a>
</nav>

<h2>Architecture graph</h2>
<pre class="mermaid">
{mermaid_def}
</pre>

<h2>Scopes</h2>
<table>
<tr><th>Scope</th><th>Files</th><th>Public API</th><th>Env vars</th><th>Errors raised</th><th>Status</th></tr>
{scope_rows}
</table>

<h2>Entrypoints</h2>
<ul>
{"".join(f'<li><code>{_h(ep)}</code></li>' for ep in index.entrypoints) if index.entrypoints else "<li>None detected</li>"}
</ul>

<h2>Environment variables</h2>
{"<table><tr><th>Variable</th><th>Default</th><th>Location</th></tr>" + env_rows + "</table>" if env_rows else "<p>None detected.</p>"}

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
  mermaid.initialize({{ startOnLoad: true, theme: 'default' }});
</script>
</body>
</html>
"""


# ---------------------------------------------------------------------------
# LLM rendering helpers
# ---------------------------------------------------------------------------

def _build_scope_summaries(index: DocsIndex) -> str:
    parts = []
    for s in index.scopes:
        status = "[FAILED]" if s.error else ""
        parts.append(f"- {s.title} ({s.scope_id}, {len(s.paths)} files) {status}")
        if s.summary:
            for line in s.summary.split("\n")[:4]:
                parts.append(f"    {line.strip()}")
    return "\n".join(parts)


def _build_scope_details(index: DocsIndex) -> str:
    parts = []
    for s in index.scopes:
        parts.append(f"### {s.title} ({s.scope_id})")
        parts.append(f"Files: {', '.join(s.paths[:20])}")
        if s.summary:
            parts.append(s.summary[:500])
        if s.public_api:
            syms = ", ".join(sym.name for sym in s.public_api[:15])
            parts.append(f"Key symbols: {syms}")
        if s.error:
            parts.append(f"ERROR: {s.error}")
        parts.append("")
    return "\n".join(parts)


async def _generate_scope_doc_llm(scope: ScopeResult, llm_client: object) -> str:
    """LLM-written per-scope module documentation."""
    from .llm import LLMClient
    assert isinstance(llm_client, LLMClient)

    api_lines = []
    for sym in scope.public_api[:50]:
        doc = f" -- {sym.docstring_first_line}" if sym.docstring_first_line else ""
        api_lines.append(f"  {sym.signature}{doc}  [{sym.citation.file}:{sym.citation.line_start}]")
    api_block = "\n".join(api_lines) or "(none)"

    env_block = ", ".join(f"{e.name} ({e.citation.file}:{e.citation.line_start})" for e in scope.env_vars) or "(none)"

    error_lines = [f"  {e.expression} [{e.citation.file}:{e.citation.line_start}]" for e in scope.raised_errors[:20]]
    error_block = "\n".join(error_lines) or "(none)"

    prompt = _SCOPE_DOC_PROMPT.format(
        title=scope.title,
        scope_id=scope.scope_id,
        file_count=len(scope.paths),
        file_list=", ".join(scope.paths[:30]) + ("..." if len(scope.paths) > 30 else ""),
        key_files=", ".join(scope.key_files) or "(none)",
        entrypoints=", ".join(scope.entrypoints) or "(none)",
        api_count=len(scope.public_api),
        api_block=api_block,
        env_block=env_block,
        error_count=len(scope.raised_errors),
        error_block=error_block,
        summary=scope.summary[:500] if scope.summary else "(none)",
    )

    return await llm_client.ask(prompt, system=_SCOPE_DOC_SYSTEM)


async def _generate_readme_llm(index: DocsIndex, llm_client: object) -> str:
    from .llm import LLMClient
    assert isinstance(llm_client, LLMClient)

    env_block = ", ".join(f"{e.name}" for e in index.env_vars) or "(none)"
    ep_block = ", ".join(index.entrypoints) or "(none)"

    prompt = _README_PROMPT.format(
        repo_path=index.repo_path,
        scope_count=len(index.scopes),
        scope_summaries=_build_scope_summaries(index),
        cross_scope_analysis=index.cross_scope_analysis or "(not available)",
        entrypoints=ep_block,
        env_vars=env_block,
        api_count=len(index.public_api),
    )
    return await llm_client.ask(prompt, system=_README_SYSTEM)


async def _generate_architecture_llm(index: DocsIndex, llm_client: object) -> str:
    from .llm import LLMClient
    assert isinstance(llm_client, LLMClient)

    env_block = ", ".join(f"{e.name}" for e in index.env_vars) or "(none)"
    ep_block = ", ".join(index.entrypoints) or "(none)"
    failed = [s.title for s in index.scopes if s.error]
    total_errors = sum(len(s.raised_errors) for s in index.scopes)

    prompt = _ARCH_PROMPT.format(
        repo_path=index.repo_path,
        cross_scope_analysis=index.cross_scope_analysis or "(not available)",
        scope_details=_build_scope_details(index),
        entrypoints=ep_block,
        env_vars=env_block,
        api_count=len(index.public_api),
        error_count=total_errors,
        failed_scopes=", ".join(failed) if failed else "(none)",
    )
    return await llm_client.ask(prompt, system=_ARCH_SYSTEM)


# ---------------------------------------------------------------------------
# Public entry points
# ---------------------------------------------------------------------------

def render(index: DocsIndex, out_dir: Path) -> list[Path]:
    """Write all docs using templates only (no LLM). Returns files written."""
    written: list[Path] = []

    docs_dir = out_dir / "docs"
    modules_dir = docs_dir / "modules"
    modules_dir.mkdir(parents=True, exist_ok=True)

    for scope in index.scopes:
        p = modules_dir / f"{scope.scope_id}.generated.md"
        p.write_text(_render_scope_md_template(scope), encoding="utf-8")
        written.append(p)

    p = out_dir / "README.generated.md"
    p.write_text(_render_readme_template(index), encoding="utf-8")
    written.append(p)

    p = docs_dir / "architecture.generated.md"
    arch = _render_architecture_template(index)
    # Append mermaid to architecture doc
    mermaid_md = "## Dependency graph\n\n```mermaid\n" + _get_mermaid(index) + "\n```\n"
    p.write_text(arch + "\n" + mermaid_md, encoding="utf-8")
    written.append(p)

    p = docs_dir / "api.generated.md"
    p.write_text(_render_api(index), encoding="utf-8")
    written.append(p)

    p = out_dir / "index.html"
    p.write_text(_render_index_html(index), encoding="utf-8")
    written.append(p)

    return written


async def render_with_llm(index: DocsIndex, out_dir: Path, llm_client: object) -> list[Path]:
    """Write all docs with LLM at every step, in parallel. Falls back to templates on failure."""
    written: list[Path] = []

    docs_dir = out_dir / "docs"
    modules_dir = docs_dir / "modules"
    modules_dir.mkdir(parents=True, exist_ok=True)

    # -- Generate ALL LLM content in parallel --------------------------------

    async def _scope_task(scope: ScopeResult) -> tuple[ScopeResult, str]:
        if scope.error:
            return scope, _render_scope_md_template(scope)
        try:
            content = await _generate_scope_doc_llm(scope, llm_client)
            return scope, content
        except Exception as exc:
            logger.warning("LLM scope doc for %s failed, using template: %s", scope.scope_id, exc)
            return scope, _render_scope_md_template(scope)

    async def _readme_task() -> str:
        try:
            return await _generate_readme_llm(index, llm_client)
        except Exception as exc:
            logger.warning("LLM README failed, using template: %s", exc)
            return _render_readme_template(index)

    async def _arch_task() -> str:
        try:
            return await _generate_architecture_llm(index, llm_client)
        except Exception as exc:
            logger.warning("LLM architecture failed, using template: %s", exc)
            return _render_architecture_template(index)

    # Fire all scope docs + README + architecture concurrently
    scope_coros = [_scope_task(s) for s in index.scopes]
    all_results = await asyncio.gather(
        *scope_coros,
        _readme_task(),
        _arch_task(),
    )

    # Unpack: first N results are scope docs, then README, then architecture
    scope_results = all_results[:len(index.scopes)]
    readme_content = all_results[len(index.scopes)]
    arch_content = all_results[len(index.scopes) + 1]

    # -- Write everything to disk -------------------------------------------

    for scope, content in scope_results:
        p = modules_dir / f"{scope.scope_id}.generated.md"
        p.write_text(content, encoding="utf-8")
        written.append(p)

    p = out_dir / "README.generated.md"
    p.write_text(readme_content, encoding="utf-8")
    written.append(p)

    mermaid_md = "\n\n## Dependency graph\n\n```mermaid\n" + _get_mermaid(index) + "\n```\n"
    p = docs_dir / "architecture.generated.md"
    p.write_text(arch_content + mermaid_md, encoding="utf-8")
    written.append(p)

    # API reference (always structured template -- it's a reference)
    p = docs_dir / "api.generated.md"
    p.write_text(_render_api(index), encoding="utf-8")
    written.append(p)

    # HTML index
    p = out_dir / "index.html"
    p.write_text(_render_index_html(index), encoding="utf-8")
    written.append(p)

    return written
